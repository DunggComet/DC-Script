--------------------------------------------------
-- C√°c H√†m Chung v√† Qu·∫£n L√Ω D·ªØ Li·ªáu R·ªìng üêâ
--------------------------------------------------
local function waitForResume()
  gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng k·ªãch b·∫£n. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
  while not gg.isVisible() do
    gg.sleep(100)
  end
  gg.setVisible(false)
end

-- ƒê·ªëi v·ªõi c√°c b∆∞·ªõc t√¨m ki·∫øm: n·∫øu h·ªßy, quay l·∫°i menu ch√≠nh.
local function safePromptSearch(prompts, defaults, types)
  local input = gg.prompt(prompts, defaults, types)
  if input == nil then
    gg.toast("‚Ü©Ô∏è Quay l·∫°i menu ch√≠nh...", true)
    waitForResume()
    return nil
  end
  return input
end

local function safeChoiceSearch(items, default, title)
  local choice = gg.choice(items, default, title)
  if choice == nil then
    gg.toast("‚Ü©Ô∏è Quay l·∫°i menu ch√≠nh...", true)
    waitForResume()
    return nil
  end
  return choice
end

-- ƒê·ªëi v·ªõi c√°c b∆∞·ªõc nh·∫≠p s·ªë: l·∫∑p l·∫°i cho ƒë·∫øn khi c√≥ ƒë·∫ßu v√†o h·ª£p l·ªá.
local function safePromptLoop(prompts, defaults, types)
  local input = gg.prompt(prompts, defaults, types)
  while input == nil do
    gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng k·ªãch b·∫£n. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
    waitForResume()
    input = gg.prompt(prompts, defaults, types)
  end
  return input
end

local function fetchDragonData()
  local response = gg.makeRequest("https://dunggcomet.github.io/DC-Script/Website/Dragon")
  if not response or not response.content then
    gg.alert("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu r·ªìng t·ª´ m√°y ch·ªß!")
    return nil
  end
  local data = {}
  for match in response.content:gmatch("<div class='dragon%-item'>(.-)</div>") do
    local cleaned = match:gsub("<[^>]+>", ""):gsub("-", ""):gsub("^%s+", ""):gsub("%s+$", "")
    if cleaned:match("^%d") then
      local code, name = cleaned:match("^(%d+)%s+(.+)$")
      if code and name then
        table.insert(data, {code = code, name = name})
      end
    end
  end
  return #data > 0 and data or nil
end

local globalDragonData = fetchDragonData()

local function getDragonNameFromCode(code)
  if not globalDragonData then return "R·ªìng Kh√¥ng X√°c ƒê·ªãnh" end
  for _, dragon in ipairs(globalDragonData) do
    if dragon.code == tostring(code) then
      return dragon.name
    end
  end
  return "R·ªìng Kh√¥ng X√°c ƒê·ªãnh"
end

local function searchDragonCode()
  if not globalDragonData then
    globalDragonData = fetchDragonData()
    if not globalDragonData then return nil end
  end

  local input = safePromptSearch({"üîç Nh·∫≠p t√™n r·ªìng ƒë·ªÉ t√¨m ki·∫øm:"}, {""}, {"text"})
  if input == nil then
    return nil
  end
  
  local searchTerm = input[1]:lower()
  local matches, codes = {}, {}
  for _, dragon in ipairs(globalDragonData) do
    if dragon.name:lower():find(searchTerm, 1, true) then
      table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name)
      table.insert(codes, dragon.code)
    end
  end
  
  if #matches == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y r·ªìng n√†o cho: " .. searchTerm)
    return nil
  end
  
  local choice = nil
  repeat
    choice = gg.choice(matches, nil, "Ch·ªçn R·ªìng C·ªßa B·∫°n:")
    if choice == nil then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng l·ª±a ch·ªçn. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      waitForResume()
    end
  until choice ~= nil
  
  return codes[choice]
end

local function searchDragonCodeLoop()
  if not globalDragonData then
    globalDragonData = fetchDragonData()
    if not globalDragonData then return nil end
  end

  local input = safePromptLoop({"üîç Nh·∫≠p t√™n r·ªìng th·ª© nh·∫•t:"}, {""}, {"text"})
  local searchTerm = input[1]:lower()
  local matches, codes = {}, {}
  for _, dragon in ipairs(globalDragonData) do
    if dragon.name:lower():find(searchTerm, 1, true) then
      table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name)
      table.insert(codes, dragon.code)
    end
  end

  if #matches == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y r·ªìng n√†o cho: " .. searchTerm)
    return nil
  end

  local choice = nil
  repeat
    choice = gg.choice(matches, nil, "Ch·ªçn R·ªìng Th·ª© Nh·∫•t:")
    if choice == nil then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng l·ª±a ch·ªçn. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      waitForResume()
    end
  until choice ~= nil

  return codes[choice]
end

local function searchDragonCodeLooop()
  if not globalDragonData then
    globalDragonData = fetchDragonData()
    if not globalDragonData then return nil end
  end

  local input = safePromptLoop({"üîç Nh·∫≠p t√™n r·ªìng th·ª© hai:"}, {""}, {"text"})
  local searchTerm = input[1]:lower()

  local matches, codes = {}, {}
  for _, dragon in ipairs(globalDragonData) do
    if dragon.name:lower():find(searchTerm, 1, true) then
      table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name)
      table.insert(codes, dragon.code)
    end
  end

  if #matches == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y r·ªìng n√†o cho: " .. searchTerm)
    return nil
  end

  local choice
  repeat
    choice = gg.choice(matches, nil, "Ch·ªçn R·ªìng Th·ª© Hai:")
    if choice == nil then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng l·ª±a ch·ªçn. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      waitForResume()
    end
  until choice ~= nil

  return codes[choice]
end

local function searchDragonCodeLoooop()
  if not globalDragonData then
    globalDragonData = fetchDragonData()
    if not globalDragonData then return nil end
  end

  local input = safePromptLoop({"üîç Nh·∫≠p t√™n r·ªìng th·ª© ba:"}, {""}, {"text"})
  local searchTerm = input[1]:lower()

  local matches, codes = {}, {}
  for _, dragon in ipairs(globalDragonData) do
    if dragon.name:lower():find(searchTerm, 1, true) then
      table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name)
      table.insert(codes, dragon.code)
    end
  end

  if #matches == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y r·ªìng n√†o cho: " .. searchTerm)
    return nil
  end

  local choice
  repeat
    choice = gg.choice(matches, nil, "Ch·ªçn R·ªìng Th·ª© Ba:")
    if choice == nil then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng l·ª±a ch·ªçn. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      waitForResume()
    end
  until choice ~= nil

  return codes[choice]
end

local function searchDragonCodeLooooop()
  if not globalDragonData then
    globalDragonData = fetchDragonData()
    if not globalDragonData then return nil end
  end

  local input = safePromptSearch({"üîç Nh·∫≠p t√™n r·ªìng cu·ªëi c√πng:"}, {""}, {"text"})
  if input == nil then
    return nil
  end
  
  local searchTerm = input[1]:lower()
  local matches, codes = {}, {}
  for _, dragon in ipairs(globalDragonData) do
    if dragon.name:lower():find(searchTerm, 1, true) then
      table.insert(matches, "üìã " .. dragon.code .. " - " .. dragon.name)
      table.insert(codes, dragon.code)
    end
  end
  
  if #matches == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y r·ªìng n√†o cho: " .. searchTerm)
    return nil
  end
  
  local choice = nil
  repeat
    choice = gg.choice(matches, nil, "Ch·ªçn R·ªìng Cu·ªëi C√πng:")
    if choice == nil then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng l·ª±a ch·ªçn. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      waitForResume()
    end
  until choice ~= nil
  
  return codes[choice]
end

local backupRankUpValues = {}       -- { [address] = {value = originalValue, flags = TYPE} }
local rankUpBaseAddresses = {}      -- danh s√°ch c√°c ƒë·ªãa ch·ªâ c∆° b·∫£n ƒë∆∞·ª£c s·ª≠a ƒë·ªïi b·ªüi doRankUp

local function revertAllRankUp()
  if next(backupRankUpValues) == nil then
    gg.alert("‚ÑπÔ∏è Kh√¥ng c√≥ s·ª≠a ƒë·ªïi tr∆∞·ªõc ƒë√≥ ƒë·ªÉ kh√¥i ph·ª•c.")
    return
  end

  local restoredCount = 0
  for addr, entry in pairs(backupRankUpValues) do
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    gg.setValues({{
      address = addr,
      flags   = entry.flags,
      value   = entry.value
    }})
    restoredCount = restoredCount + 1
    backupRankUpValues[addr] = nil
  end

  gg.toast(string.format("‚úÖ ƒê√£ kh√¥i ph·ª•c %d gi√° tr·ªã ban ƒë·∫ßu!", restoredCount), true)
  rankUpBaseAddresses = {}
end

local function featureChangeFinalDragon()
  if #rankUpBaseAddresses == 0 then
    gg.alert("‚ö†Ô∏è Mod Nhi·ªám V·ª• (RankUp) ch∆∞a ƒë∆∞·ª£c th·ª±c thi. H√£y ch·∫°y n√≥ tr∆∞·ªõc!")
    return
  end

  local newCodeStr = searchDragonCode()
  if not newCodeStr then
    gg.alert("‚ö†Ô∏è Kh√¥ng c√≥ r·ªìng n√†o ƒë∆∞·ª£c ch·ªçn. Thao t√°c b·ªã h·ªßy.")
    return
  end
  local newCode = tonumber(newCodeStr)
  if not newCode then
    gg.alert("‚ö†Ô∏è M√£ r·ªìng ¬≠r·ªìng kh√¥ng h·ª£p l·ªá ƒë∆∞·ª£c ch·ªçn.")
    return
  end

  local savedCount = 0
  local toSave = {}
  for _, baseAddr in ipairs(rankUpBaseAddresses) do
    local targetAddr = baseAddr + 0xA0
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    gg.setValues({{address = targetAddr, flags = gg.TYPE_DWORD, value = newCode}})

    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    local curr = gg.getValues({{address = targetAddr, flags = gg.TYPE_DWORD}})
    if curr and curr[1] then
      table.insert(toSave, {
        address = targetAddr,
        flags   = gg.TYPE_DWORD,
        value   = curr[1].value
      })
      savedCount = savedCount + 1
    end
  end

  if #toSave > 0 then
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    gg.addListItems(toSave)
    gg.toast(string.format("‚úÖ ƒê√£ c·∫≠p nh·∫≠t %d m√£ r·ªìng th√†nh c√¥ng!", savedCount), true)
  else
    gg.alert("‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t m√£ r·ªìng.")
  end
end

local function doRankUp()
  gg.setVisible(false)
  gg.clearResults()
  rankUpBaseAddresses = {}

  local selectedCode = searchDragonCodeLoop()
  if not selectedCode then return end
  local extraCode = searchDragonCodeLooop()
  if not extraCode then return end
  local bonusCode = searchDragonCodeLoooop()
  if not bonusCode then return end

  local IDRong  = safePromptLoop({'üîé C·∫•p ƒë·ªô r·ªìng th·ª© nh·∫•t', 'üåü H·∫°ng r·ªìng th·ª© nh·∫•t'}, {nil, nil}, {'number', 'number'})
  local IDRong2 = safePromptLoop({'üîé C·∫•p ƒë·ªô r·ªìng th·ª© hai', 'üåü H·∫°ng r·ªìng th·ª© hai'}, {nil, nil}, {'number', 'number'})
  local IDRong3 = safePromptLoop({'üîé C·∫•p ƒë·ªô r·ªìng th·ª© ba', 'üåü H·∫°ng r·ªìng th·ª© ba'}, {nil, nil}, {'number', 'number'})

  local finalDragonCode = nil
  while finalDragonCode == nil do
    gg.toast("üê≤ Ch·ªçn r·ªìng cu·ªëi c√πng ƒë·ªÉ ti·∫øp t·ª•c.", true)
    finalDragonCode = searchDragonCodeLooooop()
    if not finalDragonCode then
      gg.toast("‚è∏Ô∏è T·∫°m d·ª´ng k·ªãch b·∫£n. Nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng GG ƒë·ªÉ ti·∫øp t·ª•c!", true)
      gg.setVisible(true)
      while not gg.isVisible() do
        gg.sleep(100)
      end
      gg.setVisible(false)
    end
  end
  finalDragonCode = tonumber(finalDragonCode)
  if not finalDragonCode then
    gg.alert("‚ö†Ô∏è M√£ r·ªìng cu·ªëi c√πng kh√¥ng h·ª£p l·ªá ƒë∆∞·ª£c ch·ªçn.")
    return
  end

  ---- Giai ƒëo·∫°n 1: T√¨m ki·∫øm & Thu th·∫≠p s·ª≠a ƒë·ªïi ----
  gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
  gg.searchNumber(
    selectedCode .. ";" ..
    IDRong[1]  .. ";" ..
    IDRong[2]  .. ";" ..
    extraCode .. ";" ..
    IDRong2[1] .. ";" ..
    IDRong2[2] .. ";" ..
    bonusCode .. ";" ..
    IDRong3[1] .. ";" ..
    IDRong3[2] .. "::221",
    gg.TYPE_DWORD
  )
  gg.refineNumber(
    selectedCode .. ";" ..
    IDRong[1]  .. ";" ..
    IDRong[2]  .. ";" ..
    extraCode .. ";" ..
    IDRong2[1] .. ";" ..
    IDRong2[2] .. "::110",
    gg.TYPE_DWORD
  )
  gg.refineNumber(
    selectedCode .. ";" ..
    IDRong[1]  .. ";" ..
    IDRong[2]  .. "::55",
    gg.TYPE_DWORD
  )
  gg.refineNumber(selectedCode, gg.TYPE_DWORD)

  local gat = gg.getResults(1000)
  if not gat or #gat == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y m·ª•c n√†o ph√π h·ª£p cho Mod Nhi·ªám V·ª•.")
    return
  end

  local hasPositiveValue = false
  for _, v in ipairs(gat) do
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    local offsetValue1 = gg.getValues({{address = v.address + 0x4, flags = gg.TYPE_DWORD}})
    if offsetValue1 and offsetValue1[1] and offsetValue1[1].value > 0 then
      hasPositiveValue = true
      break
    end
  end

  local modifications = {}
  for _, v in ipairs(gat) do
    local baseAddr = v.address

    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    local off1_tbl = gg.getValues({{address = baseAddr + 0x4, flags = gg.TYPE_DWORD}})
    gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
    local off2_tbl = gg.getValues({{address = baseAddr + 0x8, flags = gg.TYPE_DWORD}})

    if not off1_tbl or not off1_tbl[1] or not off2_tbl or not off2_four[1] then
      goto skip_entry
    end

    local off1 = off1_tbl[1].value
    local off2 = off2_tbl[1].value

    local offsetsToBackup, writeInstructions

    if not hasPositiveValue and off1 == -1 then
      offsetsToBackup = {0x0, 0x8, 0x10, 0x50, 0x58, 0x60, 0xA0, 0xA8, 0xB0, 0xB8}
      writeInstructions = {
        {0x0,  1011}, {0x8,  1},   {0x10, 0},
        {0x50, 1011}, {0x58, 1},   {0x60, 0},
        {0xA0, finalDragonCode}, {0xA8, 999},
        {0xB0, 5},   {0xB8, 500}
      }

    elseif off1 > 0 and off2 ~= IDRong[1] then
      offsetsToBackup = {0x0, 0x4, 0x10, 0x50, 0x54, 0x60, 0xA0, 0xA4, 0xB0, 0xB8}
      writeInstructions = {
        {0x0,  1011}, {0x4, 1},   {0x10, 0},
        {0x50, 1011}, {0x54, 1},  {0x60, 0},
        {0xA0, finalDragonCode}, {0xA4, 999},
        {0xB0, 5},   {0xB8, 500}
      }

    elseif off1 > 0 and off2 == IDRong[1] then
      offsetsToBackup = {0x0, 0x8, 0x10, 0x50, 0x58, 0x60, 0xA0, 0xA8, 0xB0, 0xB8}
      writeInstructions = {
        {0x0,  1011}, {0x8, 1},   {0x10, 0},
        {0x50, 1011}, {0x58, 1},  {0x60, 0},
        {0xA0, finalDragonCode}, {0xA8, 999},
        {0xB0, 5},   {0xB8, 500}
      }

    elseif off2 == 0 then
      offsetsToBackup = {0x0, 0x4, 0x10, 0x50, 0x54, 0x60, 0xA0, 0xA4, 0xB0, 0xB8}
      writeInstructions = {
        {0x0,  1011}, {0x4, 1},   {0x10, 0},
        {0x50, 1011}, {0x54, 1},  {0x60, 0},
        {0xA0, finalDragonCode}, {0xA4, 999},
        {0xB0, 5},   {0xB8, 500}
      }

    else
      goto skip_entry
    end

    table.insert(modifications, {
      baseAddr = baseAddr,
      offsetsToBackup = offsetsToBackup,
      writeInstructions = writeInstructions
    })

    ::skip_entry::
  end

  if #modifications == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y m·ª•c n√†o h·ª£p l·ªá cho Mod Nhi·ªám V·ª•.")
    return
  end

  ---- Giai ƒëo·∫°n 1b: Sao l∆∞u c√°c gi√° tr·ªã g·ªëc (t·∫•t c·∫£ c√°c m·ª•c) ----
  local backupCount = 0
  for _, mod in ipairs(modifications) do
    table.insert(rankUpBaseAddresses, mod.baseAddr)

    for _, off in ipairs(mod.offsetsToBackup) do
      local addrToBackup = mod.baseAddr + off
      gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
      local orig = gg.getValues({{address = addrToBackup, flags = gg.TYPE_DWORD}})
      if orig and orig[1] then
        if not backupRankUpValues[addrToBackup] then
          backupRankUpValues[addrToBackup] = { value = orig[1].value, flags = gg.TYPE_DWORD }
          backupCount = backupCount + 1
        end
      end
    end
  end

  if backupCount == 0 then
    gg.alert("‚ö†Ô∏è Kh√¥ng th·ªÉ sao l∆∞u c√°c gi√° tr·ªã g·ªëc. Mod Nhi·ªám V·ª• b·ªã h·ªßy.")
    return
  end
  gg.toast(string.format("‚úÖ ƒê√£ sao l∆∞u %d gi√° tr·ªã th√†nh c√¥ng!", backupCount), true)

  ---- Giai ƒëo·∫°n 2: √Åp d·ª•ng c√°c thay ƒë·ªïi & l∆∞u gi√° tr·ªã m·ªõi (kh√¥ng ƒë√≥ng bƒÉng) ----
  local savedCount = 0
  for _, mod in ipairs(modifications) do
    local baseAddr = mod.baseAddr

    for _, inst in ipairs(mod.writeInstructions) do
      gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
      gg.setValues({{address = baseAddr + inst[1], flags = gg.TYPE_DWORD, value = inst[2]}})
    end

    local valuesToSave = {}
    for _, inst in ipairs(mod.writeInstructions) do
      local addrToSave = baseAddr + inst[1]
      gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
      local current = gg.getValues({{address = addrToSave, flags = gg.TYPE_DWORD}})
      if current and current[1] then
        table.insert(valuesToSave, {
          address = addrToSave,
          flags   = gg.TYPE_DWORD,
          value   = current[1].value
        })
        savedCount = savedCount + 1
      end
    end

    if #valuesToSave > 0 then
      gg.setRanges(gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS)
      gg.addListItems(valuesToSave)
    end
  end

  gg.toast(string.format("üéâ Mod Nhi·ªám V·ª• ho√†n t·∫•t! ƒê√£ l∆∞u %d gi√° tr·ªã.", savedCount), true)
  gg.sleep(1500)
end

local function featureRankUpMenu()
  while true do
    local choice = gg.choice(
      {'üöÄ Ch·∫°y Tool Quest (RankUp)',
       'üîÑ Kh√¥i ph·ª•c T·∫•t C·∫£ Thay ƒê·ªïi Mod Quest',
       'üêâ C·∫≠p Nh·∫≠t M√£ R·ªìng Cu·ªëi C√πng',
       '‚Ü©Ô∏è Quay L·∫°i Menu Ch√≠nh'},
      nil,
      'Script Quest v1 ƒê∆∞·ª£c T·∫°o B·ªüi Cometüí´üíó\nüîß T√πy Ch·ªçn Mod Quest (RankUp):'
    )
    if choice == nil then
      gg.toast('‚è∏Ô∏è Ti·∫øp t·ª•c menu Mod Nhi·ªám V·ª•...', true)
      waitForResume()
    elseif choice == 1 then
      doRankUp()
    elseif choice == 2 then
      revertAllRankUp()
    elseif choice == 3 then
      featureChangeFinalDragon()
    elseif choice == 4 then
      return
    end
  end
end
----------------
featureRankUpMenu()
